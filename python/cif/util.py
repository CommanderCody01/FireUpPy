import time
from contextlib import contextmanager
from dataclasses import dataclass
from datetime import datetime, timezone
from logging import INFO, Formatter, basicConfig, getLogger
from os import environ
from pathlib import Path
from typing import Any, Generator, List, Set

from common_metrics.metrics import Metrics

from cif.persistence import MetricLabels, MetricName

logger = getLogger(__name__)


@dataclass
class Fingerprint:
    content_type: str
    content_length: int
    version: str


def now(tzinfo: timezone = timezone.utc) -> datetime:
    """
    Create a new datetime object with a timezone (default UTC).
    """
    return datetime.now(tzinfo)


def configure_logging() -> None:
    """
    Configures the Python logging facility. Level is set to INFO or the
    value set by the LOG_LEVEL environment variable. All loggers for
    3rd party libraries should be configured here to use a consistent output format
    """
    log_format = "%(asctime)s [%(levelname)s] %(name)s:%(process)d:%(threadName)s %(message)s"
    basicConfig(
        level=environ.get("LOG_LEVEL", INFO),
        format=log_format,
    )

    uvicorn_loggers = map(getLogger, ["uvicorn", "uvicorn.error", "uvicorn.access", "uvicorn.asgi"])
    for uvicorn_logger in uvicorn_loggers:
        for handler in uvicorn_logger.handlers:
            handler.setFormatter(Formatter(log_format))

    logger.info("Logging configured")


def batcher(source: Generator[Any], batch_size: int) -> Generator[List[Any]]:
    """
    Pulls records from an AsyncGenerator in batches of a specific size.
    """
    batch = []
    for item in source:
        batch.append(item)
        if len(batch) == batch_size:
            yield batch
            batch = []
    if batch:
        yield batch


def calc_subclasses(cls: type) -> Set[type]:
    """
    Returns all subclasses for the given type.
    """
    subclasses = set()
    for subclass in cls.__subclasses__():
        subclasses.add(subclass)
        subclasses.update(calc_subclasses(subclass))
    return subclasses


def calc_version() -> str:
    """
    Reads the VERSION file generated by the build process from its installed location
    at /opt/csr-va/cif.. Returns the string contained therein or "UNKNOWN" if the file
    could not be read.
    """
    try:
        p = Path("/opt/csr-va-cif/VERSION")
        with open(p, "r") as f:
            version = f.read().strip()
            return version
    except Exception:
        return "UNKNOWN"


def flatten(lst: List[List[Any]]) -> List[Any]:
    """
    Flattens a list of list into a single list.
    """
    return [item for sublist in lst for item in sublist]


@contextmanager
def metric_timer(metrics: Metrics, metrics_labels: MetricLabels) -> Generator[None, None, None]:
    """
    Context manager for recording metrics for function calls. If an exception gets raised while the context
    is running, no metrics are recorded except the initial request count.
    """
    metrics.increment_counter(MetricName.REQUEST_COUNT, 1, labels=metrics_labels.model_dump())
    start = time.perf_counter()
    success = False
    try:
        yield
        success = True
    finally:
        metrics_labels.task_success = success
        metrics_labels_dict = metrics_labels.model_dump()
        elapsed_ms = (time.perf_counter() - start) * 1000
        metrics.increment_counter(MetricName.RESPONSE_COUNT, 1, labels=metrics_labels_dict)
        metrics.record_histogram(MetricName.REQUEST_LATENCY, elapsed_ms, labels=metrics_labels_dict)
        metrics.set_gauge_value(MetricName.REQUEST_LATENCY_CURRENT, elapsed_ms, labels=metrics_labels_dict)
